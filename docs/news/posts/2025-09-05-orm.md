---
blogpost: true
category: Blog
tags: architecture
author: Julian Geiger
date: 2025-09-05
---

# Understanding AiiDA's ORM architecture

AiiDA provides an Object-Relational Mapping (ORM) system that abstracts database operations while supporting multiple database backends.
In this post, we'll explore how AiiDA leverages SQLAlchemy to create a flexible, multi-backend ORM to separate concerns between Python objects and database persistence.

## Architecture overview: The multi-layer design

AiiDA's ORM follows a four-layer architecture that provides clean separation between the user interface, business logic, and data persistence:

```
┌─────────────────────┐
│   User Interface    │  ← Node (Python ORM class)
│     (orm/nodes)     │
├─────────────────────┤
│  Backend Interface  │  ← BackendNode (Abstract base class)
│  (implementation)   │
├─────────────────────┤
│  Database Backends  │  ← SqlaNode (SQLAlchemy implementation)
│  (psql_dos/sqlite)  │
├─────────────────────┤
│   Database Layer    │  ← DBNode (SQLAlchemy models)
│      (models)       │
└─────────────────────┘
```

This design allows AiiDA to support multiple database backends (currently PostgreSQL and SQLite) while providing a unified Python interface for users.
Importantly, users never have to interact directly with database-specific code.
Instead, they work with the high-level `Node` class (and its child classes), which automatically delegates operations to the appropriate backend implementation.

The three layers serve distinct purposes:

* __User Interface Layer__: Provides a clean, Pythonic API that hides database complexity
* __Backend Interface Layer__: Defines contracts that all database implementations must follow
* __Database Implementation Layer__: Handles the specifics of different database systems

So let's start from the bottom, shall we?

## The database: `DbNode`

AiiDA uses SQLAlchemy's declarative approach to define database tables.
This means the database schema is defined using Python classes rather than raw SQL.
Here's how the core `DbNode` model is structured:

```python
from sqlalchemy.dialects.postgresql import JSONB, UUID
from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, ForeignKey
from sqlalchemy.types import DateTime, Integer, String, Text

class DbNode(Base):
    """Database model to store data for :py:class:`aiida.orm.Node`."""
    
    __tablename__ = 'db_dbnode'

    # Primary key and unique identifier
    id = Column(Integer, primary_key=True)
    uuid = Column(UUID(as_uuid=True), default=get_new_uuid, nullable=False, unique=True)
    
    # Node classification
    node_type = Column(String(255), default='', nullable=False, index=True)
    process_type = Column(String(255), index=True)
    
    # Metadata
    label = Column(String(255), nullable=False, default='', index=True)
    description = Column(Text(), nullable=False, default='')
    ctime = Column(DateTime(timezone=True), default=timezone.now, nullable=False, index=True)
    mtime = Column(DateTime(timezone=True), default=timezone.now, onupdate=timezone.now, nullable=False, index=True)
    
    # JSON storage for flexible data
    attributes = Column(JSONB, default=dict)
    extras = Column(JSONB, default=dict)
    repository_metadata = Column(JSONB, nullable=False, default=dict)
    
    # Foreign key relationships
    dbcomputer_id = Column(Integer, ForeignKey('db_dbcomputer.id'), nullable=True, index=True)
    user_id = Column(Integer, ForeignKey('db_dbuser.id'), nullable=False, index=True)
    
    # SQLAlchemy relationships
    dbcomputer = relationship('DbComputer', backref='dbnodes')
    user = relationship('DbUser', backref='dbnodes')
```

<!-- NOTE: -->
<!-- Where base is derived from SQLAlchemy's `declarative_base`. -->

__The key features of AiiDA's SQLAlchemy models:__

1. **JSON(B) for Flexibility**: The use of PostgreSQL's `JSONB` type (`JSON` for SQLite) for `attributes`, `extras`, and `repository_metadata` provides schema flexibility while maintaining query performance.
  This is crucial for scientific computing where you can't predict what data users will want to store.
  Traditional relational databases would require creating new columns for every new property, but JSON columns let you store arbitrary structured data.

2. **UUID-based Identity**: Each node has both an integer primary key (`id` in the table, `pk` in the Python API) for database efficiency and a UUID for global uniqueness and portability.
  The integer `id` is user-friendly, fast for database joins and indexing, while the UUID allows nodes to be moved between different AiiDA installations without conflicts.

3. **Automatic Timestamps**: Creation and modification times are automatically managed through SQLAlchemy's `default` and `onupdate` parameters.

<!-- TODO: Need to understand this better myself -->
4. **Strategic Indexing**: Important columns like `node_type`, `process_type`, and timestamps are indexed for query performance.
  Without indexes, queries like "find all calculation nodes from last month" would be extremely slow.
  The indexes make these common queries fast even with millions of nodes.

<!-- TODO: Check again how SqlaNode and Node interact -->

## The contract: `BackendNode`

Above the database layer sits the abstract `BackendNode` class, which defines the interface contract that all database backend implementations must follow:

```python
class BackendNode(BackendEntity, BackendEntityExtrasMixin, metaclass=abc.ABCMeta):
    """Backend implementation for the `Node` ORM class.
    
    A node stores data input or output from a computation.
    """
    
    @abc.abstractmethod
    def clone(self: BackendNodeType) -> BackendNodeType:
        """Return an unstored clone of ourselves."""
    
    @property
    @abc.abstractmethod
    def uuid(self) -> str:
        """Return the node UUID."""
    
    @property
    @abc.abstractmethod
    def node_type(self) -> str:
        """Return the node type."""
    
    # ... many more abstract properties and methods
```

This abstract base class (ABC) ensures that regardless of which database backend is used, the same interface is available to higher-level code.
It defines essential properties like `uuid`, `node_type`, `process_type`, and methods for managing attributes, links, and storage operations.

The abstract class serves as a __contract__ - any backend implementation must provide all these methods and properties.
This guarantees that switching between PostgreSQL and SQLite backends won't break user code, since both implementations satisfy the same interface.
You can think of it like a universal power adapter: regardless of whether you're plugging into a European, US, or UK outlet, your device gets the same voltage and current.
The ``BackendNode`` abstract base class provides that standardization for database operations.

## The bridge: `SqlaNode`

The `SqlaNode` class bridges the abstract `BackendNode` interface with the concrete SQLAlchemy models:

```python
class SqlaNode(entities.SqlaModelEntity[models.DbNode], ExtrasMixin, BackendNode):
    """SQLA Node backend entity"""

    MODEL_CLASS = models.DbNode
    USER_CLASS = SqlaUser
    COMPUTER_CLASS = SqlaComputer
    LINK_CLASS = models.DbLink

    def __init__(self, backend, node_type, user, computer=None, **kwargs):
        """Construct a new `BackendNode` instance wrapping a new `DbNode` instance."""
        super().__init__(backend)
        
        arguments = {
            'node_type': node_type,
            'user': user.bare_model,
            'label': kwargs.get('label', ''),
            'description': kwargs.get('description', ''),
        }
        
        if computer:
            arguments['dbcomputer'] = computer.bare_model
            
        self._model = sqla_utils.ModelWrapper(self.MODEL_CLASS(**arguments), backend)
```

This implementation class handles:

- **Model Wrapping**: Encapsulates SQLAlchemy model instances
- **Type Safety**: Ensures proper types for related objects (users, computers)
- **Backend Abstraction**: Provides a consistent interface regardless of database backend

__The `SqlaModelEntity`__

The `SqlaModelEntity` class provides the common foundation for all SQLAlchemy-based backend entities:

```python
class SqlaModelEntity(Generic[ModelType]):
    """A mixin that adds some common SQLA backend entity methods"""
    
    @classmethod
    def from_dbmodel(cls, dbmodel, backend):
        """Create an AiiDA Entity from the corresponding SQLA ORM model"""
        entity = cls.__new__(cls)
        super(SqlaModelEntity, entity).__init__(backend)
        entity._model = utils.ModelWrapper(dbmodel, backend)
        return entity
    
    @property
    def model(self) -> utils.ModelWrapper:
        """Return an ORM model that correctly updates and flushes data"""
        return self._model
    
    @property 
    def bare_model(self):
        """Return the underlying SQLA ORM model for direct access"""
        return self.model._model
```

__The `ModelWrapper`__

The `ModelWrapper` is another crucial component that sits between AiiDA's backend entities and raw SQLAlchemy models.
It handles automatic session management, ensuring that changes are properly tracked and committed to the database.
The `bare_model` property provides direct access to the SQLAlchemy model when you need to bypass AiiDA's automatic management.

This design provides:

- __Model Wrapping__: The `ModelWrapper` encapsulates SQLAlchemy model instances with automatic session management
- __Type Safety__: Generic typing ensures proper model relationships
- __Lazy Loading__: Entity creation from database models without immediate session binding
- __Direct Access__: The `bare_model` property allows bypassing AiiDA's update/flush mechanisms when needed

__Storing data in the DB__

Actual data storage in the SQL db is achieved through the `store` method of the `SqlaNode`:

```python
def store(self, links=None, clean=True):
    session = self.backend.get_session()
    
    if clean:
        self.clean_values()
    
    session.add(self.model)
    
    if links:
        for link_triple in links:
            self._add_link(*link_triple)
    
    if not session.in_nested_transaction():
        try:
            session.commit()
        except SQLAlchemyError:
            session.rollback()
            raise
    else:
        session.flush()
    
    return self
```

This approach ensures data consistency while supporting nested transactions for complex operations.

!!! info ""

## The user interface: `Node`

At the top level, users interact with the `Node` class, which provides a Pythonic interface:

```python
class Node(Entity['BackendNode', NodeCollection], metaclass=AbstractNodeMeta):
    """Base class for all nodes in AiiDA."""
    
    def __init__(self, backend=None, user=None, computer=None, extras=None, **kwargs):
        backend = backend or get_manager().get_profile_storage()
        user = user if user else backend.default_user
        
        backend_entity = backend.nodes.create(
            node_type=self.class_node_type, 
            user=user.backend_entity, 
            computer=computer.backend_entity if computer else None,
            **kwargs
        )
        super().__init__(backend_entity)
```

Here, AiiDA uses _composition_ instead of direct _inheritance_ - the `Node` class _contains_ a `BackendNode` instance rather than being one.
The creation magic happens in `backend.nodes.create()` which returns an SqlaNode instance as shown above (automatically selecting the correct backend).

<!-- TODO: add note that for psql sqlanode is created, for sqlite an sqlitenode -->
However, note that from the user's perspective, just a `Node` is created.
The backend selection is transparent.

__Namespacing__

AiiDA uses a namespace pattern on the `Node` class to organize functionality:

```python
@cached_property
def base(self) -> NodeBase:
    """Return the node base namespace."""
    return NodeBase(self)

class NodeBase:
    """A namespace for node related functionality."""
    
    @cached_property
    def repository(self) -> 'NodeRepository':
        """Return the repository for this node."""
        return NodeRepository(self._node)
    
    @cached_property
    def attributes(self) -> 'NodeAttributes':
        """Return an interface to interact with the attributes."""
        return NodeAttributes(self._node)
    
    @cached_property
    def links(self) -> 'NodeLinks':
        """Return an interface to interact with the links."""
        return NodeLinks(self._node)
```

This namespace pattern was introduced because having all properties and methods directly on the `Node` class became overwhelming and to prevent name conflicts.
With dozens of methods for different functionalities (attributes, repository, links, caching, comments), the API became cluttered.

The namespace approach groups related functionality together:
- node.base.attributes - attribute management
- node.base.repository - file repository operations
- node.base.links - provenance links

This makes the API more discoverable and prevents method name conflicts.
It also uses @cached_property to ensure these namespace objects are created only once per node instance.

<!-- TODO: add collection pattern??? -->
<!-- NOTE: how is collection pattern different from /complements QB? -->

## Honorable mentions

### Link management: modeling relationships

AiiDA models relationships between nodes through a separate `DbLink` table:

```python
class DbLink(Base):
    """Database model to store links between nodes."""
    
    __tablename__ = 'db_dblink'
    
    id = Column(Integer, primary_key=True)
    input_id = Column(Integer, ForeignKey('db_dbnode.id'), nullable=False, index=True)
    output_id = Column(Integer, ForeignKey('db_dbnode.id', ondelete='CASCADE'), nullable=False, index=True)
    
    input = relationship('DbNode', primaryjoin='DbLink.input_id == DbNode.id')
    output = relationship('DbNode', primaryjoin='DbLink.output_id == DbNode.id')
    
    label = Column(String(255), nullable=False, index=True)
    type = Column(String(255), nullable=False, index=True)
```

Rather than storing relationships as simple foreign keys, each link is a first-class entity with its own metadata.
The `label` field describes the specific role of the link (e.g., "structure", "parameters", "output_data"), while the type field categorizes the kind of relationship (e.g., "input", "output", "call").
This metadata enables complex provenance queries like "find all structures that were relaxed using PBE exchange-correlation functional."
The `ondelete='CASCADE'` on the output relationship ensures that when a node is deleted, all its incoming links are also removed, maintaining referential integrity.

### The QueryBuilder

The `QueryBuilder` is AiiDA's main API provided to retrieve data from the database.
It provides a uniform, backend-agnostic interface:

```python
# Simple node query
qb = QueryBuilder()
qb.append(Node, filters={'label': {'like': 'calculation%'}})
results = qb.all()

# Complex relationship query
qb = QueryBuilder()
qb.append(StructureData, tag='structure')
qb.append(CalcJobNode, with_incoming='structure', tag='calc')
qb.append(FolderData, with_incoming='calc', project=['*'])
```

The QueryBuilder automatically:

* __Converts ORM Classes__: Maps Node classes to their corresponding database entities
* __Handles Relationships__: Translates with_incoming/with_outgoing to proper SQL joins
* __Type Filtering_: Automatically adds filters for node types and subtypes
* __Backend Translation__: Converts the same query syntax to PostgreSQL or SQLite SQL

### Pydantic models: Modern Serialization

Recently, AiiDA incorporated Pydantic models for modern data validation and serialization:

```python
class Node(Entity['BackendNode', NodeCollection]):
    """Base class for all nodes in AiiDA with Pydantic model support."""
    
    class Model(Entity.Model):
        """Pydantic model for Node serialization and validation."""
        
        uuid: Optional[str] = MetadataField(None, description='The UUID of the node')
        node_type: Optional[str] = MetadataField(None, description='The type of the node')
        
        attributes: Optional[Dict[str, Any]] = MetadataField(
            None,
            description='The node attributes',
            orm_to_model=lambda node, _: node.base.attributes.all,
            is_subscriptable=True,
            exclude_to_orm=True,
        )
        
        repository_content: Optional[dict[str, bytes]] = MetadataField(
            None,
            description='Dictionary of file repository content encoded as base64',
            orm_to_model=lambda node, _: {
                key: base64.encodebytes(content)
                for key, content in node.base.repository.serialize_content().items()
            },
            exclude_to_orm=True,
        )
    
    def serialize(self, repository_path: Optional[pathlib.Path] = None) -> dict[str, Any]:
        """Serialize the entity instance to JSON."""
        if repository_path is None:
            repository_path = pathlib.Path(tempfile.mkdtemp()) / f'./aiida_serialization/{self.pk}/'
            repository_path.mkdir(parents=True)
        return self._to_model(repository_path).model_dump()
    
    @classmethod
    def from_serialized(cls, **kwargs: dict[str, Any]) -> 'Node':
        """Construct an entity instance from JSON serialized data."""
        return cls._from_model(cls.Model(**kwargs))
```

This enables:
- **Automatic Validation**: Pydantic validates data types and constraints
- **Serialization**: Convert ORM objects to/from JSON for export/import
- **API Integration**: Direct compatibility with FastAPI and other modern frameworks
- **Schema Documentation**: Auto-generated OpenAPI schemas for web interfaces

### NodeCollections: The interface pattern

The `NodeCollection` class provides a clean interface for managing collections of nodes:

```python
class NodeCollection(EntityCollection[NodeType], Generic[NodeType]):
    """The collection of nodes."""
    
    def delete(self, pk: int) -> None:
        """Delete a Node from the collection with the given id"""
        node = self.get(id=pk)
        
        if node.base.links.get_incoming().all():
            raise exceptions.InvalidOperation(f'cannot delete Node<{node.pk}> because it has incoming links')
            
        if node.base.links.get_outgoing().all():
            raise exceptions.InvalidOperation(f'cannot delete Node<{node.pk}> because it has outgoing links')
            
        self._backend.nodes.delete(pk)
```
This collection pattern provides several benefits:

* __Type safety__: Generic typing ensures you get the correct node type back
* __Validation__: Prevents deletion of nodes with existing links to maintain provenance integrity
* __Backend abstraction__: Hides database-specific operations behind a clean interface

## Key Takeaways

AiiDA's ORM architecture makes use of several important design principles:

1. **Multi-Layer Abstraction**: The multi-layer design (User Interface → Backend Interface → Database Implementation) provides clean separation while allowing backend-specific optimizations.

2. **Automatic Backend Adaptation**: The PostgreSQL-to-SQLite conversion system shows how to maintain feature parity across different database engines without code duplication.

3. **Strategic Use of JSON**: JSONB columns provide schema flexibility without sacrificing query performance, with automatic adaptation to SQLite's JSON1 extension.

4. **Namespace Organization**: The namespace pattern (`node.base.attributes`, `node.base.repository`) keeps APIs clean while providing rich functionality.

5. **Universal Query Interface**: The query builder abstraction allows identical query syntax across backends while leveraging each database's strengths.

6. **Type Safety Throughout**: Strong typing and generic programming prevent common errors and improve maintainability.

7. **Modern Integration**: Pydantic model integration brings modern Python data validation and serialization capabilities to the ORM.

8. **Collection Patterns**: The collection system provides a consistent, intuitive interface for data access that scales from simple lookups to complex queries.

This architecture allows AiiDA to provide a powerful, flexible ORM that adapts to different database backends while maintaining a consistent user experience.

<!-- TODO: -->
<!-- Add statement that the whole infrastructure also had to be implemented for the other, specialized data types of AiiDA -->
<!-- Add some admonititions? -->
<!-- add gh permalinks -->

