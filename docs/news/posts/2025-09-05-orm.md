---
blogpost: true
category: Blog
tags: usability
author: Julian Geiger
date: 2025-09-05
---

# Understanding AiiDA's ORM architecture

AiiDA provides an Object-Relational Mapping (ORM) system that abstracts database operations while supporting multiple database backends.
In this post, we'll explore how AiiDA leverages SQLAlchemy to create a flexible, multi-backend ORM to separate concerns between Python objects and database persistence.

## Architecture Overview: The Three-Layer Design

AiiDA's ORM follows a three-layer architecture that provides clean separation between the user interface, business logic, and data persistence:

```
┌─────────────────────┐
│   User Interface    │  ← Node (Python ORM class)
│     (orm/nodes)     │
├─────────────────────┤
│  Backend Interface  │  ← BackendNode (Abstract base class)
│  (implementation)   │
├─────────────────────┤
│ Database Backends   │  ← SqlaNode (SQLAlchemy implementation)
│ (psql_dos/sqlite)   │
└─────────────────────┘
```

This design allows AiiDA to support multiple database backends (currently PostgreSQL and SQLite) while providing a unified Python interface for users.

## The Abstract Foundation: BackendNode

At the heart of AiiDA's architecture is the abstract `BackendNode` class, which defines the contract that all database backend implementations must follow:

```python
class BackendNode(BackendEntity, BackendEntityExtrasMixin, metaclass=abc.ABCMeta):
    """Backend implementation for the `Node` ORM class.
    
    A node stores data input or output from a computation.
    """
    
    @abc.abstractmethod
    def clone(self: BackendNodeType) -> BackendNodeType:
        """Return an unstored clone of ourselves."""
    
    @property
    @abc.abstractmethod
    def uuid(self) -> str:
        """Return the node UUID."""
    
    @property
    @abc.abstractmethod
    def node_type(self) -> str:
        """Return the node type."""
    
    # ... many more abstract properties and methods
```

This abstract base class (ABC) ensures that regardless of which database backend is used, the same interface is available to higher-level code.
It defines essential properties like `uuid`, `node_type`, `process_type`, and methods for managing attributes, links, and storage operations.

## SQLAlchemy Models: Defining Database Structure

AiiDA uses SQLAlchemy's declarative approach to define database tables.
Here's how the core `DbNode` model is structured:

```python
from sqlalchemy.dialects.postgresql import JSONB, UUID
from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, ForeignKey
from sqlalchemy.types import DateTime, Integer, String, Text

class DbNode(Base):
    """Database model to store data for :py:class:`aiida.orm.Node`."""
    
    __tablename__ = 'db_dbnode'

    # Primary key and unique identifier
    id = Column(Integer, primary_key=True)
    uuid = Column(UUID(as_uuid=True), default=get_new_uuid, nullable=False, unique=True)
    
    # Node classification
    node_type = Column(String(255), default='', nullable=False, index=True)
    process_type = Column(String(255), index=True)
    
    # Metadata
    label = Column(String(255), nullable=False, default='', index=True)
    description = Column(Text(), nullable=False, default='')
    ctime = Column(DateTime(timezone=True), default=timezone.now, nullable=False, index=True)
    mtime = Column(DateTime(timezone=True), default=timezone.now, onupdate=timezone.now, nullable=False, index=True)
    
    # JSON storage for flexible data
    attributes = Column(JSONB, default=dict)
    extras = Column(JSONB, default=dict)
    repository_metadata = Column(JSONB, nullable=False, default=dict)
    
    # Foreign key relationships
    dbcomputer_id = Column(Integer, ForeignKey('db_dbcomputer.id'), nullable=True, index=True)
    user_id = Column(Integer, ForeignKey('db_dbuser.id'), nullable=False, index=True)
    
    # SQLAlchemy relationships
    dbcomputer = relationship('DbComputer', backref='dbnodes')
    user = relationship('DbUser', backref='dbnodes')
```

### Key Features of AiiDA's SQLAlchemy Models

1. **JSONB for Flexibility**: The use of PostgreSQL's `JSONB` type for `attributes`, `extras`, and `repository_metadata` provides schema flexibility while maintaining query performance.

2. **UUID-based Identity**: Each node has both an integer primary key (`id`) for database efficiency and a UUID for global uniqueness and portability.

3. **Automatic Timestamps**: Creation and modification times are automatically managed through SQLAlchemy's `default` and `onupdate` parameters.

4. **Strategic Indexing**: Important columns like `node_type`, `process_type`, and timestamps are indexed for query performance.

## The Implementation Bridge: SqlaNode

The `SqlaNode` class bridges the abstract `BackendNode` interface with the concrete SQLAlchemy models:

```python
class SqlaNode(entities.SqlaModelEntity[models.DbNode], ExtrasMixin, BackendNode):
    """SQLA Node backend entity"""

    MODEL_CLASS = models.DbNode
    USER_CLASS = SqlaUser
    COMPUTER_CLASS = SqlaComputer
    LINK_CLASS = models.DbLink

    def __init__(self, backend, node_type, user, computer=None, **kwargs):
        """Construct a new `BackendNode` instance wrapping a new `DbNode` instance."""
        super().__init__(backend)
        
        arguments = {
            'node_type': node_type,
            'user': user.bare_model,
            'label': kwargs.get('label', ''),
            'description': kwargs.get('description', ''),
        }
        
        if computer:
            arguments['dbcomputer'] = computer.bare_model
            
        self._model = sqla_utils.ModelWrapper(self.MODEL_CLASS(**arguments), backend)
```

This implementation class handles:

- **Model Wrapping**: Encapsulates SQLAlchemy model instances
- **Type Safety**: Ensures proper types for related objects (users, computers)
- **Backend Abstraction**: Provides a consistent interface regardless of database backend

## The User-Facing Interface: Node Class

At the top level, users interact with the `Node` class, which provides a Pythonic interface:

```python
class Node(Entity['BackendNode', NodeCollection], metaclass=AbstractNodeMeta):
    """Base class for all nodes in AiiDA."""
    
    def __init__(self, backend=None, user=None, computer=None, extras=None, **kwargs):
        backend = backend or get_manager().get_profile_storage()
        user = user if user else backend.default_user
        
        backend_entity = backend.nodes.create(
            node_type=self.class_node_type, 
            user=user.backend_entity, 
            computer=computer.backend_entity if computer else None,
            **kwargs
        )
        super().__init__(backend_entity)
        
        if extras is not None:
            self.base.extras.set_many(extras)
```

### The Namespace Pattern

AiiDA uses a namespace pattern on the `Node` class to organize functionality:

```python
@cached_property
def base(self) -> NodeBase:
    """Return the node base namespace."""
    return NodeBase(self)

class NodeBase:
    """A namespace for node related functionality."""
    
    @cached_property
    def repository(self) -> 'NodeRepository':
        """Return the repository for this node."""
        return NodeRepository(self._node)
    
    @cached_property
    def attributes(self) -> 'NodeAttributes':
        """Return an interface to interact with the attributes."""
        return NodeAttributes(self._node)
    
    @cached_property
    def links(self) -> 'NodeLinks':
        """Return an interface to interact with the links."""
        return NodeLinks(self._node)
```

<!--  TODO: -->
This was implemented as previously having all properties and methods directly on the `Node` class became too excessive.

<!-- This allows for intuitive access patterns like `node.base.attributes.set('key', 'value')` and `node.base.repository.put_object_from_file()`. -->

## Database Backend Differences

<!-- NOTE: Probably too detailed -->
<!-- ### PostgreSQL vs SQLite Considerations -->
<!---->
<!-- AiiDA supports both PostgreSQL and SQLite, with some important differences: -->
<!---->
<!-- **PostgreSQL Features:** -->
<!-- ```python -->
<!-- # JSONB provides efficient JSON storage and indexing -->
<!-- attributes = Column(JSONB, default=dict) -->
<!---->
<!-- # PostgreSQL-specific indexes for pattern matching -->
<!-- __table_args__ = ( -->
<!--     Index('ix_pat_db_dbnode_label', label,  -->
<!--           postgresql_using='btree',  -->
<!--           postgresql_ops={'label': 'varchar_pattern_ops'}), -->
<!-- ) -->
<!-- ``` -->
<!---->
<!-- **SQLite Adaptations:** -->
<!-- - Uses `JSON` instead of `JSONB` for JSON storage -->
<!-- - Different indexing strategies for text pattern matching -->
<!-- - May have limitations on concurrent write operations -->

<!-- ### Database Driver Dependencies -->
<!---->
<!-- AiiDA uses different drivers for each backend: -->
<!---->
<!-- - **PostgreSQL**: `psycopg` - A mature, C-based adapter providing: -->
<!--   - High performance -->
<!--   - Full PostgreSQL feature support (including JSONB) -->
<!--   - Robust connection pooling -->
<!--   - Advanced data type support -->
<!---->
<!-- - **SQLite**: Uses Python's built-in `sqlite3` module, providing: -->
<!--   - Zero configuration -->
<!--   - File-based storage -->
<!--   - Perfect for development and testing -->

<!-- ## Attribute Management: Flexible JSON Storage -->
<!---->
<!-- In addition to the fixed base data types, AiiDA allows for a flexible attribute system, implemented using JSON columns: -->
<!---->
<!-- ```python -->
<!-- def set_attribute(self, key: str, value: Any) -> None: -->
<!--     validate_attribute_extra_key(key) -->
<!--      -->
<!--     if self.is_stored: -->
<!--         value = clean_value(value) -->
<!--      -->
<!--     self.model.attributes[key] = value -->
<!--     self._flush_if_stored({'attributes'}) -->
<!---->
<!-- def get_attribute(self, key: str) -> Any: -->
<!--     try: -->
<!--         return self.model.attributes[key] -->
<!--     except KeyError as exception: -->
<!--         raise AttributeError(f'attribute `{exception}` does not exist') from exception -->
<!-- ``` -->
<!---->
<!-- The `clean_value` function ensures that Python objects are properly serialized for JSON storage, while `validate_attribute_extra_key` enforces naming conventions. -->

## Link Management: Modeling Relationships

AiiDA models relationships between nodes through a separate `DbLink` table:

```python
class DbLink(Base):
    """Database model to store links between nodes."""
    
    __tablename__ = 'db_dblink'
    
    id = Column(Integer, primary_key=True)
    input_id = Column(Integer, ForeignKey('db_dbnode.id'), nullable=False, index=True)
    output_id = Column(Integer, ForeignKey('db_dbnode.id', ondelete='CASCADE'), nullable=False, index=True)
    
    input = relationship('DbNode', primaryjoin='DbLink.input_id == DbNode.id')
    output = relationship('DbNode', primaryjoin='DbLink.output_id == DbNode.id')
    
    label = Column(String(255), nullable=False, index=True)
    type = Column(String(255), nullable=False, index=True)
```

which enables provenance tracking by storing not only the relationship, but also metadata about the relationship type and label.

## Storage and Transaction Management

AiiDA implements sophisticated storage logic with transaction support:

```python
def store(self, links=None, clean=True):
    session = self.backend.get_session()
    
    if clean:
        self.clean_values()
    
    session.add(self.model)
    
    if links:
        for link_triple in links:
            self._add_link(*link_triple)
    
    if not session.in_nested_transaction():
        try:
            session.commit()
        except SQLAlchemyError:
            session.rollback()
            raise
    else:
        session.flush()
    
    return self
```

This approach ensures data consistency while supporting nested transactions for complex operations.

## Pydantic Model Integration: Modern Serialization

Recently, AiiDA incorporated Pydantic models for modern data validation and serialization:

```python
class Node(Entity['BackendNode', NodeCollection]):
    """Base class for all nodes in AiiDA with Pydantic model support."""
    
    class Model(Entity.Model):
        """Pydantic model for Node serialization and validation."""
        
        uuid: Optional[str] = MetadataField(None, description='The UUID of the node')
        node_type: Optional[str] = MetadataField(None, description='The type of the node')
        
        attributes: Optional[Dict[str, Any]] = MetadataField(
            None,
            description='The node attributes',
            orm_to_model=lambda node, _: node.base.attributes.all,
            is_subscriptable=True,
            exclude_to_orm=True,
        )
        
        repository_content: Optional[dict[str, bytes]] = MetadataField(
            None,
            description='Dictionary of file repository content encoded as base64',
            orm_to_model=lambda node, _: {
                key: base64.encodebytes(content)
                for key, content in node.base.repository.serialize_content().items()
            },
            exclude_to_orm=True,
        )
    
    def serialize(self, repository_path: Optional[pathlib.Path] = None) -> dict[str, Any]:
        """Serialize the entity instance to JSON."""
        if repository_path is None:
            repository_path = pathlib.Path(tempfile.mkdtemp()) / f'./aiida_serialization/{self.pk}/'
            repository_path.mkdir(parents=True)
        return self._to_model(repository_path).model_dump()
    
    @classmethod
    def from_serialized(cls, **kwargs: dict[str, Any]) -> 'Node':
        """Construct an entity instance from JSON serialized data."""
        return cls._from_model(cls.Model(**kwargs))
```

This enables:
- **Automatic Validation**: Pydantic validates data types and constraints
- **Serialization**: Convert ORM objects to/from JSON for export/import
- **API Integration**: Direct compatibility with FastAPI and other modern frameworks
- **Schema Documentation**: Auto-generated OpenAPI schemas for web interfaces

## Key Takeaways

AiiDA's ORM architecture demonstrates several important design principles:

1. **Multi-Layer Abstraction**: The three-layer design (User Interface → Backend Interface → Database Implementation) provides clean separation while allowing backend-specific optimizations.

2. **Automatic Backend Adaptation**: The PostgreSQL-to-SQLite conversion system shows how to maintain feature parity across different database engines without code duplication.

3. **Strategic Use of JSON**: JSONB columns provide schema flexibility without sacrificing query performance, with automatic adaptation to SQLite's JSON1 extension.

4. **Namespace Organization**: The namespace pattern (`node.base.attributes`, `node.base.repository`) keeps APIs clean while providing rich functionality.

5. **Universal Query Interface**: The query builder abstraction allows identical query syntax across backends while leveraging each database's strengths.

6. **Type Safety Throughout**: Strong typing and generic programming prevent common errors and improve maintainability.

7. **Modern Integration**: Pydantic model integration brings modern Python data validation and serialization capabilities to the ORM.

8. **Collection Patterns**: The collection system provides a consistent, intuitive interface for data access that scales from simple lookups to complex queries.

This architecture allows AiiDA to provide a powerful, flexible ORM that adapts to different database backends while maintaining a consistent user experience. The careful balance between abstraction and performance, combined with modern Python practices, makes it an excellent example of how to build scalable scientific software that can evolve with changing requirements and technologies.

The system's ability to automatically convert PostgreSQL models to SQLite equivalents, while maintaining query compatibility through sophisticated backend-specific implementations, demonstrates how thoughtful architecture can provide both flexibility and performance without compromising on either.

