---
blogpost: true
category: Blog
tags: architecture
author: Julian Geiger
date: 2025-09-05
---

# Understanding AiiDA's ORM architecture

In this post, we'll take a deep dive into the implementation of AiiDA's Object-Relational Mapping (ORM) system.
We'll explore how AiiDA leverages [SQLAlchemy](https://github.com/sqlalchemy/sqlalchemy) to create a flexible (ORM) backend that abstracts database operations and separates concerns between the user-facing Python objects and the underlying database persistence.

## Architecture overview: The multi-layer design

AiiDA's ORM follows a four-layer architecture that provides clean separation between the user interface, business logic, and data persistence:

```
┌─────────────────────┐
│   User interface    │  ← Node (Python ORM class)
│     (orm/nodes)     │
├─────────────────────┤
│  Backend interface  │  ← BackendNode (Abstract base class)
│  (implementation)   │
├─────────────────────┤
│  Database backends  │  ← SqlaNode (SQLAlchemy implementation)
│  (psql_dos/sqlite)  │
├─────────────────────┤
│   Database layer    │  ← DBNode (SQLAlchemy models)
│      (models)       │
└─────────────────────┘
```

Each layer serves a distinct purposes:

* __User interface layer__: Provides a clean, Pythonic API that hides database complexity
* __Backend interface layer__: Defines contracts that all database implementations must follow
* __Database implementation layer__: Handles the specifics of different database systems
* __Database model layer__: Defines the actual table schemas and relationships using SQLAlchemy's declarative approach

Importantly, you, the user never have to interact directly with database-specific code.
Instead, you can work with the high-level `Node` class (and its derived classes), while AiiDA automatically delegates database operations to the appropriate backend implementation.
This design further allows AiiDA to support multiple database backends (currently PostgreSQL and SQLite), while providing a unified Python interface for users.

Let's start from the bottom and work our way up, shall we?

## The database: `DbNode`

AiiDA uses SQLAlchemy's declarative approach to define database tables.
This means the database schema is defined using Python classes rather than raw SQL.
Here's how the core
[`DbNode`](https://github.com/aiidateam/aiida-core/blob/313f342f5d28eeba5967fec8196ed6fce393a77a/src/aiida/storage/psql_dos/models/node.py#L22)
model is constructed:

```python
from sqlalchemy.dialects.postgresql import JSONB, UUID
from sqlalchemy.orm import relationship
from sqlalchemy.schema import Column, ForeignKey
from sqlalchemy.types import DateTime, Integer, String, Text

class DbNode(Base):
    """Database model to store data for :py:class:`aiida.orm.Node`."""
    
    __tablename__ = 'db_dbnode'

    # Primary key and unique identifier
    id = Column(Integer, primary_key=True)
    uuid = Column(UUID(as_uuid=True), default=get_new_uuid, nullable=False, unique=True)
    
    # Node classification
    node_type = Column(String(255), default='', nullable=False, index=True)
    process_type = Column(String(255), index=True)
    
    # Metadata
    label = Column(String(255), nullable=False, default='', index=True)
    description = Column(Text(), nullable=False, default='')
    ctime = Column(DateTime(timezone=True), default=timezone.now, nullable=False, index=True)
    mtime = Column(DateTime(timezone=True), default=timezone.now, onupdate=timezone.now, nullable=False, index=True)
    
    # JSON storage for flexible data
    attributes = Column(JSONB, default=dict)
    extras = Column(JSONB, default=dict)
    repository_metadata = Column(JSONB, nullable=False, default=dict)
    
    # Foreign key relationships
    dbcomputer_id = Column(Integer, ForeignKey('db_dbcomputer.id'), nullable=True, index=True)
    user_id = Column(Integer, ForeignKey('db_dbuser.id'), nullable=False, index=True)
    
    # SQLAlchemy relationships
    dbcomputer = relationship('DbComputer', backref='dbnodes')
    user = relationship('DbUser', backref='dbnodes')
```

The `Base` class from which `DbNode` inherits is derived from SQLAlchemy's `declarative_base()`, which provides the metaclass and base functionality that allows Python classes to be automatically mapped to database tables.

```python
Base = declarative_base(
  cls=Model,
  name='Model',
  metadata=MetaData(naming_convention=dict(naming_convention))
)
```
This declarative approach means that table schemas, constraints, relationships, and indexes are all defined in Python code rather than separate SQL files, making the database structure self-documenting and version-controllable alongside the application logic.

__Key features of AiiDA's SQLAlchemy models:__

1. **Use of JSON(B) for flexibility**: The use of PostgreSQL's `JSONB` (and SQLite's `JSON`) type for `attributes`, `extras`, and `repository_metadata` provides schema flexibility while maintaining query performance.
  This is crucial for scientific computing where one can't predict what data users will want to store.
  Traditional relational databases would require creating new columns for every new property, but JSON columns let you store arbitrary structured data (as long as it's JSON-serializable).
2. **UUID-based Identity**: Each node has both an integer primary key (`id` in the table, `pk` in the Python API[^1]) for database efficiency and a UUID for global uniqueness and portability.
  The integer `id` is user-friendly, fast for database joins and indexing, while the UUID allows nodes to be moved between different AiiDA installations without conflicts.
3. **Automatic Timestamps**: Creation and modification times are automatically managed through SQLAlchemy's `default` and `onupdate` parameters.
4. **Strategic Indexing**: Important columns like `node_type`, `process_type`, and timestamps are indexed for query performance.
  Without indexes, queries like "find all calculation nodes from last month" would be extremely slow.
  The indexes make these common queries fast even with millions of nodes.

## The contract: `BackendNode`

Above the database layer sits the abstract
[`BackendNode`](https://github.com/aiidateam/aiida-core/blob/313f342f5d28eeba5967fec8196ed6fce393a77a/src/aiida/orm/implementation/nodes.py#L27)
class, which defines the interface contract that all database backend implementations must follow:

```python
class BackendNode(BackendEntity, BackendEntityExtrasMixin, metaclass=abc.ABCMeta):
    """Backend implementation for the `Node` ORM class.
    
    A node stores data input or output from a computation.
    """
    
    @abc.abstractmethod
    def clone(self: BackendNodeType) -> BackendNodeType:
        """Return an unstored clone of ourselves."""
    
    @property
    @abc.abstractmethod
    def uuid(self) -> str:
        """Return the node UUID."""
    
    @property
    @abc.abstractmethod
    def node_type(self) -> str:
        """Return the node type."""
    
    # ... many more abstract properties and methods
```

This abstract base class (ABC) ensures that regardless of which database backend is used, the same interface is available to higher-level code.
It defines essential properties like `uuid`, `node_type`, `process_type`, and methods for managing attributes, links, and storage operations.

The abstract class serves as a __contract__ - any backend implementation must provide all these methods and properties.
This guarantees that switching between PostgreSQL and SQLite backends won't break user code, since both implementations satisfy the same interface.

## The bridge: `SqlaNode`

The
[`SqlaNode`](https://github.com/aiidateam/aiida-core/blob/313f342f5d28eeba5967fec8196ed6fce393a77a/src/aiida/storage/psql_dos/orm/nodes.py#L30)
class bridges the abstract `BackendNode` interface with the concrete SQLAlchemy models:

```python
class SqlaNode(entities.SqlaModelEntity[models.DbNode], ExtrasMixin, BackendNode):
    """SQLA Node backend entity"""

    MODEL_CLASS = models.DbNode
    USER_CLASS = SqlaUser
    COMPUTER_CLASS = SqlaComputer
    LINK_CLASS = models.DbLink

    def __init__(self, backend, node_type, user, computer=None, **kwargs):
        """Construct a new `BackendNode` instance wrapping a new `DbNode` instance."""
        super().__init__(backend)
        
        arguments = {
            'node_type': node_type,
            'user': user.bare_model,
            'label': kwargs.get('label', ''),
            'description': kwargs.get('description', ''),
        }
        
        if computer:
            arguments['dbcomputer'] = computer.bare_model
            
        self._model = sqla_utils.ModelWrapper(self.MODEL_CLASS(**arguments), backend)

    ...

    def store(self, links=None, clean=True):
    session = self.backend.get_session()
    
    if clean:
        self.clean_values()
    
    session.add(self.model)
    
    if links:
        for link_triple in links:
            self._add_link(*link_triple)
    
    if not session.in_nested_transaction():
        try:
            session.commit()
        except SQLAlchemyError:
            session.rollback()
            raise
    else:
        session.flush()
    
    return self
```

The `SqlaNode` class wraps a raw `DbNode` SQLAlchemy model in a 
[`ModelWrapper`](https://github.com/aiidateam/aiida-core/blob/313f342f5d28eeba5967fec8196ed6fce393a77a/src/aiida/storage/psql_dos/orm/utils.py#L27)
that handles session management automatically. This design provides several key capabilities:

* __Model wrapping__: Encapsulates SQLAlchemy model instances with automatic session tracking
* __Type safety__: Generic typing ensures proper relationships between related objects (users, computers)
* __Backend abstraction__: Provides a consistent interface regardless of database backend
* __Direct access__: The `bare_model` property allows bypassing AiiDA's automatic management when needed

The key insight is that `SqlaNode` provides two levels of access:

* `node.model`: The wrapped model with automatic session tracking
* `node.bare_model`: Direct access to the raw SQLAlchemy mode

## The user interface: `Node`

At the top level, users interact with the `Node` class, which uses compososition to contain an `SqlaNode` instance, and provides a Pythonic interface to users:

```python
class Node(Entity['BackendNode', NodeCollection], metaclass=AbstractNodeMeta):
    """Base class for all nodes in AiiDA."""
    
    def __init__(self, backend=None, user=None, computer=None, extras=None, **kwargs):
        backend = backend or get_manager().get_profile_storage()
        user = user if user else backend.default_user
        
        backend_entity = backend.nodes.create(
            node_type=self.class_node_type, 
            user=user.backend_entity, 
            computer=computer.backend_entity if computer else None,
            **kwargs
        )
        super().__init__(backend_entity)
```

The creation magic happens in `backend.nodes.create()` which returns an `SqlaNode` instance[^2] as shown above (automatically selecting the correct backend).
However, note that from the user's perspective, just a `Node` is created-the backend selection is transparent.

Here's how all of this looks like in action in a `verdi shell`:

```python
In [1]: n = Int(1).store()

In [2]: n.backend_entity
Out[2]: <aiida.storage.psql_dos.orm.nodes.SqlaNode at 0x7d8ac6d53880>

In [3]: n.backend_entity.model
Out[3]: <aiida.storage.psql_dos.orm.utils.ModelWrapper at 0x7d8ac6c6fcd0>

In [4]: n.backend_entity.bare_model
Out[4]: <DbNode id=103522, uuid=UUID('70cd..., node_type='data.core..., process_type=None, label='', description='', ctime=datetime.d..., mtime=datetime.d..., attributes={'value': ..., extras={'_aiida_h..., repository_metadata={}, dbcomputer_id=None, user_id=1,>
```

__Namespacing__

AiiDA uses a namespace pattern on the `Node` class to organize functionality:

```python
class Node(Entity['BackendNode', NodeCollection], metaclass=AbstractNodeMeta):
    """Base class for all nodes in AiiDA."""
    
    ...

    @cached_property
    def base(self) -> NodeBase:
        """Return the node base namespace."""
        return NodeBase(self)

class NodeBase:
    """A namespace for node related functionality."""
    
    @cached_property
    def repository(self) -> 'NodeRepository':
        """Return the repository for this node."""
        return NodeRepository(self._node)
    
    @cached_property
    def attributes(self) -> 'NodeAttributes':
        """Return an interface to interact with the attributes."""
        return NodeAttributes(self._node)
    
    @cached_property
    def links(self) -> 'NodeLinks':
        """Return an interface to interact with the links."""
        return NodeLinks(self._node)
```

This namespace pattern was introduced because having all properties and methods directly on the `Node` class became overwhelming, making the API cluttered, and prone to name conflicts.

The namespace approach further groups related functionality together:
- `node.base.attributes` `NodeAttributes` - attribute management
- `node.base.repository -> NodeRepository` - file repository operations
- `node.base.links -> NodeLinks` - provenance links

and the use of `@cached_property` ensures that these namespace objects are created only once per node instance.[^3]

## Honorable mentions

### Link management: modeling relationships

AiiDA models relationships between nodes through a separate `DbLink` table:

```python
class DbLink(Base):
    """Database model to store links between nodes."""
    
    __tablename__ = 'db_dblink'
    
    id = Column(Integer, primary_key=True)
    input_id = Column(Integer, ForeignKey('db_dbnode.id'), nullable=False, index=True)
    output_id = Column(Integer, ForeignKey('db_dbnode.id', ondelete='CASCADE'), nullable=False, index=True)
    
    input = relationship('DbNode', primaryjoin='DbLink.input_id == DbNode.id')
    output = relationship('DbNode', primaryjoin='DbLink.output_id == DbNode.id')
    
    label = Column(String(255), nullable=False, index=True)
    type = Column(String(255), nullable=False, index=True)
```

Rather than storing relationships as simple foreign keys, each link is a first-class entity with its own metadata.
The `label` field describes the specific role of the link (e.g., "structure", "parameters", "output_data"), while the type field categorizes the kind of relationship (e.g., "input", "output", "call").
This metadata enables complex provenance queries like "find all structures that were relaxed using PBE exchange-correlation functional."
The `ondelete='CASCADE'` on the output relationship ensures that when a node is deleted, all its incoming links are also removed, maintaining referential integrity.

### The QueryBuilder

The `QueryBuilder` is AiiDA's main Python API to retrieve data from the database.
It provides a uniform, backend-agnostic interface:

<!-- TODO: change example -->
```python
# Simple node query
qb = QueryBuilder()
qb.append(Node, filters={'label': {'like': 'calculation%'}})
results = qb.all()

# Complex relationship query
qb = QueryBuilder()
qb.append(StructureData, tag='structure')
qb.append(CalcJobNode, with_incoming='structure', tag='calc')
qb.append(FolderData, with_incoming='calc', project=['*'])
```

The QueryBuilder automatically:

* __Converts ORM Classes__: Maps Node classes to their corresponding database entities
* __Handles Relationships__: Translates with_incoming/with_outgoing to proper SQL joins
* __Type Filtering_: Automatically adds filters for node types and subtypes
* __Backend Translation__: Converts the same query syntax to PostgreSQL or SQLite SQL

### Pydantic models: Modern Serialization

Recently, AiiDA incorporated Pydantic models for modern data validation and serialization:

```python
class Node(Entity['BackendNode', NodeCollection]):
    """Base class for all nodes in AiiDA with Pydantic model support."""
    
    class Model(Entity.Model):
        """Pydantic model for Node serialization and validation."""
        
        uuid: Optional[str] = MetadataField(None, description='The UUID of the node')
        node_type: Optional[str] = MetadataField(None, description='The type of the node')
        
        attributes: Optional[Dict[str, Any]] = MetadataField(
            None,
            description='The node attributes',
            orm_to_model=lambda node, _: node.base.attributes.all,
            is_subscriptable=True,
            exclude_to_orm=True,
        )
        
        repository_content: Optional[dict[str, bytes]] = MetadataField(
            None,
            description='Dictionary of file repository content encoded as base64',
            orm_to_model=lambda node, _: {
                key: base64.encodebytes(content)
                for key, content in node.base.repository.serialize_content().items()
            },
            exclude_to_orm=True,
        )
    
    def serialize(self, repository_path: Optional[pathlib.Path] = None) -> dict[str, Any]:
        """Serialize the entity instance to JSON."""
        if repository_path is None:
            repository_path = pathlib.Path(tempfile.mkdtemp()) / f'./aiida_serialization/{self.pk}/'
            repository_path.mkdir(parents=True)
        return self._to_model(repository_path).model_dump()
    
    @classmethod
    def from_serialized(cls, **kwargs: dict[str, Any]) -> 'Node':
        """Construct an entity instance from JSON serialized data."""
        return cls._from_model(cls.Model(**kwargs))
```

This enables:
- **Automatic Validation**: Pydantic validates data types and constraints
- **Serialization**: Convert ORM objects to/from JSON for export/import
- **API Integration**: Direct compatibility with FastAPI and other modern frameworks
- **Schema Documentation**: Auto-generated OpenAPI schemas for web interfaces

### NodeCollections: The interface pattern

The `NodeCollection` class provides a clean interface for managing collections of nodes:

```python
class NodeCollection(EntityCollection[NodeType], Generic[NodeType]):
    """The collection of nodes."""
    
    def delete(self, pk: int) -> None:
        """Delete a Node from the collection with the given id"""
        node = self.get(id=pk)
        
        if node.base.links.get_incoming().all():
            raise exceptions.InvalidOperation(f'cannot delete Node<{node.pk}> because it has incoming links')
            
        if node.base.links.get_outgoing().all():
            raise exceptions.InvalidOperation(f'cannot delete Node<{node.pk}> because it has outgoing links')
            
        self._backend.nodes.delete(pk)
```
This collection pattern provides several benefits:

* __Type safety__: Generic typing ensures you get the correct node type back
* __Validation__: Prevents deletion of nodes with existing links to maintain provenance integrity
* __Backend abstraction__: Hides database-specific operations behind a clean interface

## Key Takeaways

AiiDA's ORM architecture makes use of several important design principles:

1. **Multi-Layer Abstraction**: The multi-layer design (User Interface → Backend Interface → Database Implementation) provides clean separation while allowing backend-specific optimizations.

2. **Automatic Backend Adaptation**: The PostgreSQL-to-SQLite conversion system shows how to maintain feature parity across different database engines without code duplication.

3. **Strategic Use of JSON**: JSONB columns provide schema flexibility without sacrificing query performance, with automatic adaptation to SQLite's JSON1 extension.

4. **Namespace Organization**: The namespace pattern (`node.base.attributes`, `node.base.repository`) keeps APIs clean while providing rich functionality.

5. **Universal Query Interface**: The query builder abstraction allows identical query syntax across backends while leveraging each database's strengths.

6. **Type Safety Throughout**: Strong typing and generic programming prevent common errors and improve maintainability.

7. **Modern Integration**: Pydantic model integration brings modern Python data validation and serialization capabilities to the ORM.

8. **Collection Patterns**: The collection system provides a consistent, intuitive interface for data access that scales from simple lookups to complex queries.

This architecture allows AiiDA to provide a powerful, flexible ORM that adapts to different database backends while maintaining a consistent user experience.


__Footnotes__
[^1]:
  To avoid confusion with Python's `id()` function.
[^2]:
  For the SQLite backend, an `SqliteNode` is actually created, which, however, inherits from `SqlaNode`.
[^3]:
  Although we do understand that the `node.base` approach can be non-intuitive for first time users.


<!-- TODO: -->
<!-- Add statement that the whole infrastructure also had to be implemented for the other, specialized data types of AiiDA -->
<!-- Add some admonititions? -->
<!-- add gh permalinks -->

<!-- NOTE: how is collection pattern different from /complements QB? -->

